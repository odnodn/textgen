import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import * as chance from 'chance';
import { TranslateModule } from "@ngx-translate/core";

import { By } from "@angular/platform-browser";
import * as _ from "lodash";

import {ReactiveFormsModule, FormsModule} from '@angular/forms';

{% set cname =  (entity.name  ) +'Component'  %}
import { {{ cname }} } from './{{ name |fLower }}.component';

{% macro genFieldTest(entity) %}
    {% for prop in genUtils.getAllSimpleProps(entity) + genUtils.getOutgoingRefs(entity) -%}
        it('{{ prop.name }} field validity', () => {
        let errors = {};
        let fld = component.getTheForm().controls['{{ prop.name }}'];

        {%  if not prop.opt %}
        expect(fld.valid).toBeFalsy();


        //  field is required
        errors = fld.errors || {};
        expect(errors['required']).toBeTruthy();
        {% endif %}

        {% for v in prop.validators %}
            {% if  v.name =='pattern' %}
        fld.setValue("to");
        errors = fld.errors || {};
        expect(errors['required']).toBeFalsy();
        expect(errors['pattern']).toBeTruthy();
            {% endif %}
            {% if  v.name =='min' %}
        fld.setValue("to");
        errors = fld.errors || {};
        expect(errors['required']).toBeFalsy();
        expect(errors['minlength']).toBeTruthy();
            {% endif %}
        {% endfor %}

        {%  if prop.validators.min %}
        // Set field to something

        {% endif %}

        {%  if prop.validators.pattern %}
            // Set field to something
            fld.setValue("to");
            errors = fld.errors || {};
            expect(errors['required']).toBeFalsy();
            expect(errors['pattern']).toBeTruthy();
        {% endif %}

        // Set field to something correct
        fld.setValue(entity.{{ prop.name }});
        errors = fld.errors || {};
        expect(errors).toEqual({});

        });
{#        // {{ prop.name }} : ['', [  {{ getValidators(prop) }} ]],#}
    {% endfor %}
{#    {% for prop in genUtils.getContained(entity) -%}#}
{#        {{ prop.name }} : this.fb.array([ this.create{{ prop.name | fUpper }}Controls() ])#}
{#    {% endfor %}#}
{%  endmacro %}





describe('{{ cname }}', () => {
let component: {{ cname }};
let fixture: ComponentFixture<{{ cname }}>;

const entity = {
{% for prop in genUtils.allProps(entity) -%}
    {% if genUtils.isSimple(prop) -%}
        {{ prop.name }} : {{ genUtils.getTestDataJS(prop) }},
    {% else -%}
        {{ prop.name }} : null
    {% endif %}
{% endfor %}
};

    beforeEach(async(() => {
        TestBed.configureTestingModule({
        declarations: [ {{ cname }} ],
        imports: [ReactiveFormsModule,
FormsModule,
TranslateModule.forRoot()
],

    })
        .compileComponents();
    }));

    beforeEach(() => {
        fixture = TestBed.createComponent({{ cname }});
        component = fixture.componentInstance;
        fixture.detectChanges();
    });

    it('should create', () => {
        expect(component).toBeTruthy();
    });

    it('form invalid when empty', () => {
        expect(component.getTheForm().valid).toBeFalsy();
    });

    {{  genFieldTest(entity) }}


    it("submitting the form emits valid entity", () => {
        expect(component.getTheForm().valid).toBeFalsy();
        component.entity = entity;

        _.forOwn(entity, (value, key) => {
            component.getTheForm().controls[key].setValue(value);
        });

        expect(component.getTheForm().valid).toBeTruthy();

        let output: any;

        // Subscribe to the Observable and store the output in a local variable.
        component.stepComplete.subscribe(value => {
        output = value;
        console.log(value);
        });

        // Trigger the output function
        component.submit();
        fixture.detectChanges();

        // Now we can check to make sure the emitted value is correct
        expect(output).toEqual(entity);
    });

});
